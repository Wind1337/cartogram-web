/**
 * @fileOverview This file contains the frontend UI for the go-cart.io web application
 * @author Ian Duncan, Atima Tharatipyakul
 * @version 3.0.0
 */

import * as d3 from 'd3'

import { MapVersionData, MapDataFormat, MapVersion } from './mapVersion.js'
import CartMap from './cartMap.js'
import type { Mappack } from './interface.js'

/**
 * Cartogram contains the main frontend logic for the go-cart web application.
 */
export default class Cartogram {
  cartogram_data_dir: string
  scale: number

  /**
   * The cartogram model
   * @property {CartMap|null} map The current map
   * @property {string} current_sysname The sysname of the map version selected for viewing on the right
   * @property {string} map_sysname The sysname of the currently selected map
   * @property {boolean} in_loading_state Whether or not we're in a loading state
   * @property {Object|null} loading_state The current loading state
   */
  model = {
    map: null as CartMap | null,
    current_sysname: '',
    map_sysname: '',
    in_loading_state: false,
    loading_state: null as Object | null
  }

  constructor(c_d: string, scale = 1.3) {
    this.cartogram_data_dir = c_d
    this.scale = scale
  }

  /**
   * requestAndDrawCartogram generates and displays a cartogram with a user-provided dataset. Always returns false to
   * prevent form submission.
   *
   * This is a two step process. First, we make a request to CartogramUI. This generates color and tooltip information
   * from the uploaded dataset, as well as the areas string that needs to be given to the cartogram generator to
   * actually generate the cartogram with the given dataset.
   *
   * Once it receives the areas string, the cartogram generator produces a streaming HTTP response with information on
   * the progress of cartogram generation, and the cartogram points in JSON format. The information from CartogramUI
   * and the cartogram generator is then combined to draw the cartogram with the correct colors and tooltip
   * information.
   * @param {Object} gd The grid document to retrieve the dataset from. If null, the dataset is taken from the
   * uploaded CSV file
   * @param {string} sysname The sysname of the map. If null, it is taken from the map selection form control.
   * @param {boolean} update_grid_document Wether to update the grid document with the grid document returned from
   * CartogramUI
   * @returns {boolean}
   */
  // async requestAndDrawCartogram(gd = null, sysname = null, update_grid_document = true) {
  //   if (this.model.in_loading_state) return false

  //   this.clearNonFatalError()

  //   /* Do some validation */

  //   if (gd === null && document.getElementById('csv').files.length < 1) {
  //     this.doNonFatalError(Error('You must upload CSV/Excel data.'))
  //     return false
  //   }

  //   // We check if the xlsx to csv conversion is ready; if not, we wait until it is
  //   this.enterLoadingState()
  //   this.showProgressBar()

  //   if (sysname === null) {
  //     sysname = document.getElementById('handler').value
  //   }

  //   var cartogramui_promise

  //   /*
  //       If we're submitting a grid document, convert it and pretend to upload a CSV file. Otherwise, actually upload the
  //       CSV file the user specified.
  //       */

  //   if (gd === null) {
  //     // Moved to UploadBtn
  //   } else {
  //     var cartogramui_req_body = this.generateCartogramUIRequestBodyFromGridDocument(sysname, gd)

  //     cartogramui_promise = HTTP.post(this.config.cartogramui_url, cartogramui_req_body.req_body, {
  //       'Content-Type': 'multipart/form-data; boundary=' + cartogramui_req_body.mime_boundary
  //     })
  //   }

  //   cartogramui_promise.then(
  //     function (response) {
  //       if (response.error == 'none') {
  //         // moved to c

  //         const yesButton = document.createElement('button')
  //         yesButton.className = 'btn btn-primary mr-5'
  //         yesButton.innerText = 'Yes, I Confirm'
  //         yesButton.addEventListener(
  //           'click',
  //           function (sysname, response) {
  //             return function (e) {

  //                 }.bind(this),
  //                 function (err) {
  //                   this.doFatalError(err)
  //                   console.log(err)

  //                   this.drawBarChartFromTooltip('barchart', response.tooltip)
  //                   document.getElementById('barchart-container').style.display = 'block'
  //                 }.bind(this)
  //               )
  //             }.bind(this)
  //           }.bind(this)(sysname, response)
  //         )

  //         pieChartButtonsContainer.appendChild(yesButton)
  //         pieChartButtonsContainer.appendChild(noButton)

  //         this.drawPieChartFromTooltip('piechart-area', response.tooltip, colors)
  //         this.exitLoadingState()
  //         document.getElementById('piechart').style.display = 'block'
  //       } else {
  //         this.exitLoadingState()
  //         document.getElementById('cartogram').style.display = 'block'
  //         this.doNonFatalError(Error(response.error))
  //       }
  //     }.bind(this),
  //     this.doFatalError
  //   )

  //   return false
  // }

  /**
   * switchMap loads a new map with the given sysname, and displays the conventional and population versions, as well
   * as an optional extra cartogram.
   * @param {string} sysname The sysname of the new map to load
   * @param {string} hrname The human-readable name of the new map to load
   * @param mappack
   * @param {MapVersionData} cartogram An optional, extra cartogram to display
   * @param {string} sharing_key The unique sharing key associated with this
   *                             cartogram, if any
   */
  switchMap(
    sysname: string,
    hrname: string,
    mappack: Mappack,
    cartogram: MapVersionData | null = null,
    sharing_key: string | null = null
  ) {
    var map = new CartMap(hrname, mappack.config, this.scale)
    map.addVersion(
      '1-conventional',
      MapVersionData.mapVersionDataFromMappack(mappack, mappack.original),
      '1-conventional'
    )
    map.addVersion(
      '2-population',
      MapVersionData.mapVersionDataFromMappack(mappack, mappack.original),
      '1-conventional'
    )
    if (cartogram !== null) {
      map.addVersion('3-cartogram', cartogram, '1-conventional')
    }

    /*
      The keys in the colors.json file are prefixed with id_. We iterate through the regions and extract the color
      information from colors.json to produce a color map where the IDs are plain region IDs, as required by
      CartMap.
      */
    var colors: { [key: string]: string } = {}

    Object.keys(map.regions).forEach(function (region_id) {
      colors[region_id] = mappack.colors['id_' + region_id]
    }, this)

    map.colors = colors

    map.drawVersion('1-conventional', 'map-area', ['map-area', 'cartogram-area'])

    if (cartogram !== null) {
      map.drawVersion('3-cartogram', 'cartogram-area', ['map-area', 'cartogram-area'])
      this.model.current_sysname = '3-cartogram'
    } else {
      map.drawVersion('2-population', 'cartogram-area', ['map-area', 'cartogram-area'])
      this.model.current_sysname = '2-population'
    }

    this.model.map = map
  }
}
